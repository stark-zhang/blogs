<!DOCTYPE html><html lang="[&quot;zh-CN&quot;,&quot;default&quot;]" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>可综合的SystemVerilog：打破SystemVerilog只适用于验证的神话（Part 1） | Stephen Zhang's Blog</title><meta name="author" content="stephen zhang"><meta name="copyright" content="stephen zhang"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="&quot;Synthensizing SystemVerilog, Busting the Myth that SystemVerilog is only for Verification&quot;翻译，第一部分">
<meta property="og:type" content="article">
<meta property="og:title" content="可综合的SystemVerilog：打破SystemVerilog只适用于验证的神话（Part 1）">
<meta property="og:url" content="https://blogs.stephen-zhang.cn/post/a706f59a/">
<meta property="og:site_name" content="Stephen Zhang&#39;s Blog">
<meta property="og:description" content="&quot;Synthensizing SystemVerilog, Busting the Myth that SystemVerilog is only for Verification&quot;翻译，第一部分">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://blogs.stephen-zhang.cn/images/avatar.jpeg">
<meta property="article:published_time" content="2023-06-11T16:44:34.000Z">
<meta property="article:modified_time" content="2024-09-24T19:40:35.799Z">
<meta property="article:author" content="stephen zhang">
<meta property="article:tag" content="HDL">
<meta property="article:tag" content="Verilog">
<meta property="article:tag" content="SystemVerilog">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://blogs.stephen-zhang.cn/images/avatar.jpeg"><link rel="shortcut icon" href="/images/favicon.ico"><link rel="canonical" href="https://blogs.stephen-zhang.cn/post/a706f59a/"><link rel="preconnect" href="//cdnjs.cloudflare.com"/><link rel="preconnect" href="//hm.baidu.com"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta name="baidu-site-verification" content="code-rzFVk1pD5y"/><link rel="stylesheet" href="/css/index.css?v=4.13.0"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/node-snackbar/0.1.16/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancyapps-ui/5.0.33/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?7690d855badf77d19385d41b87879ca0";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: {"limitDay":500,"position":"top","messagePrev":"It has been","messageNext":"days since the last update, the content of the article may be outdated."},
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体中文","cht_to_chs":"你已切换为简体中文","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#1f1f1f","position":"bottom-left"},
  infinitegrid: {
    js: 'https://cdnjs.cloudflare.com/ajax/libs/egjs-infinitegrid/4.11.1/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: true,
  islazyload: true,
  isAnchor: true,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '可综合的SystemVerilog：打破SystemVerilog只适用于验证的神话（Part 1）',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-09-25 03:40:35'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><link href="https://cdn.staticfile.org/lxgw-wenkai-screen-webfont/1.7.0/style.min.css" rel="stylesheet"><meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="Stephen Zhang's Blog" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/images/avatar.jpeg" onerror="onerror=null;src='/images/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">33</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">49</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">16</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page group hide" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="fa-fw fas fa-compass"></i><span> 目录</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page group hide" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="fa-fw fas fa-bookmark"></i><span> 合辑</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/collections/commMobile"><i class="fa-fw fas fa-signal"></i><span> 移动通信</span></a></li><li><a class="site-page child" href="/collections/commBasic"><i class="fa-fw fas fa-wave-square"></i><span> 通信基础</span></a></li><li><a class="site-page child" href="/collections/reading"><i class="fa-fw fas fa-book-open-reader"></i><span> 读书笔记</span></a></li><li><a class="site-page child" href="/collections/notes"><i class="fa-fw fas fa-note-sticky"></i><span> 杂谈</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/friends/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" target="_blank" rel="noopener external nofollow noreferrer" href="https://www.travellings.cn/go.html"><i class="fa-fw fas fa-subway"></i><span> 开往</span></a></div><div class="menus_item"><a class="site-page" href="/profile/"><i class="fa-fw fas fa-user"></i><span> 关于我</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="not-top-img" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="Stephen Zhang's Blog"><span class="site-name">Stephen Zhang's Blog</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page group hide" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="fa-fw fas fa-compass"></i><span> 目录</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page group hide" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="fa-fw fas fa-bookmark"></i><span> 合辑</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/collections/commMobile"><i class="fa-fw fas fa-signal"></i><span> 移动通信</span></a></li><li><a class="site-page child" href="/collections/commBasic"><i class="fa-fw fas fa-wave-square"></i><span> 通信基础</span></a></li><li><a class="site-page child" href="/collections/reading"><i class="fa-fw fas fa-book-open-reader"></i><span> 读书笔记</span></a></li><li><a class="site-page child" href="/collections/notes"><i class="fa-fw fas fa-note-sticky"></i><span> 杂谈</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/friends/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" target="_blank" rel="noopener external nofollow noreferrer" href="https://www.travellings.cn/go.html"><i class="fa-fw fas fa-subway"></i><span> 开往</span></a></div><div class="menus_item"><a class="site-page" href="/profile/"><i class="fa-fw fas fa-user"></i><span> 关于我</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="fas fa-bars fa-fw"></i></a></div></div></nav></header><main class="layout" id="content-inner"><div id="post"><div id="post-info"><h1 class="post-title">可综合的SystemVerilog：打破SystemVerilog只适用于验证的神话（Part 1）</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-06-11T16:44:34.000Z" title="发表于 2023-06-12 00:44:34">2023-06-12</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-09-24T19:40:35.799Z" title="更新于 2024-09-25 03:40:35">2024-09-25</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/technical/">technical</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/technical/translation/">translation</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/technical/translation/synthensizing-sv/">synthensizing-sv</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="可综合的SystemVerilog：打破SystemVerilog只适用于验证的神话（Part 1）"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div><article class="post-content" id="article-container"><h3 id="Preface">Preface</h3>
<p>译者的话：本文是<a target="_blank" rel="noopener external nofollow noreferrer" href="https://www.sutherland-hdl.com/papers/2013-SNUG-SV_Synthesizable-SystemVerilog_paper.pdf"><em>synthensizing SystemVerilog, Busting the Myth that SystemVerilog is only for Verification</em></a>的译文，计划分成三到四个部分完成，作为译者学习RTL设计的入门纪念。参考文献将以脚注的形式给出。</p>
<p>关于作者：</p>
<ul>
<li><a href="mailto:stuart@sutherland-hdl.com" rel="external nofollow noreferrer">Stuart Sutherland</a>: Sutherland HDL, Inc.的创始人</li>
<li><a href="mailto:mills@microchip.com" rel="external nofollow noreferrer">Don Mills</a>：Microchip公司高级工程师</li>
</ul>
<p>以下是译文正文。</p>
<h3 id="摘要">摘要</h3>
<p>SystemVerilog绝不仅仅是用于验证的！它最初被发明的时候，其中一个主要目标就是使人们可以使用更少的代码更准确地描述复杂硬件设计的可综合模型。这个目标 已经实现了，而且Synopsys已经在Design Compiler(DC)和Sysnplify-Pro中完成了实现SystemVerilog的主要工作。这篇文章主要测试了SystemVerilog可综合子集的细节，以及展示了相对传统Verilog而言，使用这些新的结构的优势。读者将从本文中学到新的RTL建模技能，这些技能确实可以用更少的代码行进行建模，同时减少潜在的设计错误并实现高综合结果质量。</p>
<p><em>目标受众：使用ASIC和FPGA参与RTL设计和综合的工程师们。</em></p>
<h3 id="1-0-引言-——-SystemVerilog-v-s-Verilog的真相">1.0 引言 —— SystemVerilog v.s. Verilog的真相</h3>
<p>总有一种常见的误解，认为<em>Verilog</em>是一种可综合的硬件建模语言，而<em>SystemVerilog</em>是一种不可综合的验证语言。<strong>这是完全错误的！</strong></p>
<p>自从1984年Verilog语言被引入以来，它就肩负了两个目标，分别是为硬件建模以及描述硬件测试平台（testbench）。许多Verilog语言的结构，例如<code>if...else...</code>，既可用于建模，也可用于验证。此外Verilog中也存在大量仅可用于验证的结构，例如<code>$display</code>，不存在与它们直接对应的硬件结构。综合关心的是语言中与硬件建模相关的部分，因此原始的Verilog语言中仅有一个子集支持综合。</p>
<p>IEEE于1995年正式将Verilog标准化，标准号是<strong>1364-1995</strong>，因此它也被称为<strong>Verilog-1995</strong><sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>。然后IEEE开始着手扩充Verilog，使之同时支持验证和设计，2001年，标准<strong>1364-2001</strong><sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup>，或称Verilog-2001发布。一年后，IEEE发布<strong>1364.1-2002 Verilog RTL Synthesis</strong><sup class="footnote-ref"><a href="#fn3" id="fnref3">[3]</a></sup>标准，正式定义了Verilog-2001中可综合的子集。</p>
<p>IEEE后来也升级Verilog标准到1364-2005，又称Verilog-2005<sup class="footnote-ref"><a href="#fn4" id="fnref4">[4]</a></sup>。然而，集成电路的功能、复杂度和时钟速率在2000年后演化的是如此迅速，以至于Verilog标准的增量更新已经不足以跟上硬件模型和验证测试对语言能力所持续增长的需求。IEEE为增强Verilog语言而定义的新特性越来越多，以至于有必要为其分配一个新的标准编号描述语言的扩展内容，即1800-2005，又称<strong>SystemVerilog</strong> <sup class="footnote-ref"><a href="#fn5" id="fnref5">[5]</a></sup>。<strong>SystemVerilog并非是一种全新的语言 —— 它只是在Verilog-2005基础上提供了一组扩展。</strong> 分成两份文档的原因之一是为了帮助那些供应Verilog仿真器和综合编译器的公司能专注实现所有的新功能。</p>
<p><strong>然后是混乱的名称演变……</strong> 2009年，IEEE将Verilog 1364-2005和SystemVerilog扩展（1800-2005）合并为一个文档。出于作者一直无法理解的原因，IEEE选择停用原来的Verilog名称，而将合并后的新标准改称为SystemVerilog。从此，原始的1364 Verilog标准结束了，IEEE批准了<strong>1800-2009</strong>，即SystemVerilog-2009<sup class="footnote-ref"><a href="#fn6" id="fnref6">[6]</a></sup>作为一个完整的硬件设计和验证语言。在IEEE的术语里，Verilog标准已经不复存在，现在只有SystemVerilog标准。<strong>2009年以来，你再也没有使用过Verilog…… 而是使用SytemVerilog进行设计和综合工作！</strong>（IEEE随后发布了SystemVerilog-2012标准，其中包括了对原始的、现已不复存在的Verilog标准的额外增强）</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2023/06/30/wDzfO3UuRkC2o4E.png" alt="Figure 1. Verilog到SystemVerilog的发展"></p>
<p>值得注意的是，SystemVerilog同时扩展了Verilog在硬件建模和测试验证的能力。Figure 1是语言的发展路线，虽不完善，但是也足以说明SystemVerilog对原始Verilog的大量扩展增强了硬件建模能力。本文的重点就是这些语言结构是如何综合的，以及使用这些SystemVerilog扩展在硬件设计中的优势。</p>
<p>本文的目的是提供一个在Synopsys Desgin Compiler和/或Synplify-Pro中可综合部分的全面的清单。重点是SystemVerilog增加的那部分组件，以及作为用户如何利用这些改进。为完整起见，本文也会提及不同版本Verilog中的可综合组件，但不会过多讨论其细节。</p>
<p>还应该注意的是，现在没有一份关于SystemVerilog综合的标准。IEEE选择不更新1364.1以反映<br>
SystemVerilog中新增的可综合扩展。作者认为这是短视的，同时也是在损害工程社区，但是也系希望本文与旧的1364.1-2002 Verilog综合标准结合使用，能作为一个SystemVerilog可综合子集的官方标准。</p>
<h3 id="2-数据类型">2 数据类型</h3>
<p><strong>注意</strong>：本文使用的术语“值集”（Value Sets）用于表示二态值（0, 1）和四态值（0, 1, X, Z）。而术语“数据类型”是一个通用术语，泛指所有的线网类型、变量类型和用户定义类型。在IEEE正式的SystemVerilog标准<sup class="footnote-ref"><a href="#fn7" id="fnref7">[7]</a></sup>中，这两个术语的用法与此处不同，这是因为标准文档主要是面向提供仿真器或者综合编译器一类软件工具的公司和组织。标准中使用的术语，诸如“类型”（types）、“对象”（objects）和“类别”（kinds），对于工具的实现者具有特殊含义，但是作者认为它们对于使用SystemVerilog的工程师们既不通俗也不直观。</p>
<h4 id="2-1-值集">2.1 值集</h4>
<p>原始Verilog中仅存在四态值，即向量中的每个比特可以取值0, 1, X, Z。SystemVerilog在此基础上增加了表示二态值的能力，即每个比特只能取值0或1。相应地，增加了新的关键字<code>bit</code>和<code>logic</code>分别用于表示二态值和四态值。SystemVerilog中的线网类型，如<code>wire</code>，只能使用<code>logic</code>的四态值集。对变量而言，四态值类型和二态值类型都是可用的。（对于仿真器和综合编译器的实现者而言，这两个关键字还有更多的含义，不过对于理解如何通过SystemVerilog进行模拟设计而言已经足够了。）</p>
<p>关键字<code>bit</code>和<code>logic</code>也可以在不明确定义线网类型或变量类型的情况下使用，此时具体是线网还是变量是通过上下文自动推导得到的。关键字<code>bit</code>总是被推导为变量类型，而大多数情况下，关键字<code>logic</code>会被推导为变量类型，而在与关键字<code>input</code>、<code>inout</code>一起使用时，才会被推导为线网类型。下面的声明展示了这些推导规则：</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> A;</span><br><span class="line">  ...</span><br><span class="line"><span class="keyword">endmodule</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> M (</span><br><span class="line">  <span class="comment">// 带推导的模块端口声明</span></span><br><span class="line">  <span class="keyword">input</span>         i1, <span class="comment">// 推导为四态线网</span></span><br><span class="line">  <span class="keyword">input</span> <span class="keyword">logic</span>   i2, <span class="comment">// 推导为四态线网</span></span><br><span class="line">  <span class="keyword">input</span> <span class="keyword">bit</span>     i3, <span class="comment">// 推导为二态变量</span></span><br><span class="line">  <span class="keyword">output</span>        o1, <span class="comment">// 推导为四态线网</span></span><br><span class="line">  <span class="keyword">output</span> <span class="keyword">logic</span>  o2, <span class="comment">// 推导为四态变量</span></span><br><span class="line">  <span class="keyword">output</span> <span class="keyword">bit</span>    o3  <span class="comment">// 推导为二态变量</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 带推导或明确声明的内部信号</span></span><br><span class="line">  <span class="keyword">bit</span>   clock;          <span class="comment">// 推导为二态变量</span></span><br><span class="line">  <span class="keyword">logic</span> reset;          <span class="comment">// 推导为四态变量</span></span><br><span class="line">  <span class="keyword">logic</span> [<span class="number">7</span>:<span class="number">0</span>] data;     <span class="comment">// 推导为四态变量</span></span><br><span class="line">  <span class="keyword">wire</span>  [<span class="number">7</span>:<span class="number">0</span>] n1;       <span class="comment">// 显式声明为现网类型，推导为四态logic</span></span><br><span class="line">  <span class="keyword">wire</span> <span class="keyword">logic</span> [<span class="number">7</span>:<span class="number">0</span>] n2;  <span class="comment">// 显式声明为四态线网</span></span><br><span class="line">  <span class="keyword">var</span>   [<span class="number">7</span>:<span class="number">0</span>] v1;       <span class="comment">// 显式声明为变量，推导为logic</span></span><br><span class="line">  <span class="keyword">var</span>   <span class="keyword">logic</span> [<span class="number">7</span>:<span class="number">0</span>] v2; <span class="comment">// 显式声明为四态变量</span></span><br><span class="line">  ...</span><br><span class="line"><span class="keyword">endmodule</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><em><strong>重要：</strong> 在综合中，<code>bit</code>和<code>logic</code>是等同的，四态和二态值集仅用于仿真，对综合无意义。</em></p>
<ul>
<li><strong>SystemVerilog的优势之一</strong>：不再需要担心模块端口应该声明为<code>wire</code>或<code>reg</code>（更明确些，现网类型还是变量类型）。在SystemVerilog中，你可以将模块端口和局部信号都声明为<code>logic</code>，它们将会被正确地推导为合适的线网类型或者变量类型（可能偶有例外，工程师有时也会希望明确地使用和推导结果不同的类型，但是此种例外较少见）。</li>
</ul>
<p>注意验证代码略有不同。在testbench中，随机生成的变量应该被声明为<code>bit</code>（二态）而非<code>logic</code>（四态）。关于在设计与验证代码中二态和四态类型的详细讨论，见Sutherland<sup class="footnote-ref"><a href="#fn8" id="fnref8">[8]</a></sup>。</p>
<h4 id="2-2-线网类型">2.2 线网类型</h4>
<p>可综合的线网类型有：</p>
<ul>
<li><code>wire</code>和<code>tri</code>：允许并支持多驱动的互联线网</li>
<li><code>supply0</code>和<code>supply1</code>：分别为带有常量0和常量1的互联线网</li>
<li><code>wand</code>、<code>triand</code>、<code>wor</code>和<code>trior</code>：将多个驱动相与（AND）或相或（OR）的互联线网</li>
</ul>
<p>由于它们一直都是Verilog的一部分，本文不讨论这些线网类型进行综合时的细节。请参考Verilog RTL综合标准1364.1或者综合编译器的文档以获取更多传统Verilog类型综合的信息。</p>
<ul>
<li><strong>SystemVerilog优势之二</strong>（至少它应该算作优势）：SystemVerilog同时提供了能对设计工作带来巨大潜在优势的线网类型<code>uwire</code>，但是它现在尚不支持综合。本文的第12章将详细介绍为什么在设计工作中<code>uwire</code>是一个重要的优势。</li>
</ul>
<h4 id="2-3-变量类型">2.3 变量类型</h4>
<p>变量用于过程代码，或称<code>alway</code>块中。Verilog/SystemVerilog均要求过程赋值语句的左侧必须是变量类型。SystemVerilog中可综合的变量类型如下：</p>
<ul>
<li><code>reg</code>：用户自定义长度的通用四态变量</li>
<li><code>integer</code>：一个32比特的四态变量</li>
<li><code>logic</code>：推导为用户自定义长度的通用四态变量，除了位于模块的<code>input</code>/<code>inout</code>端口上</li>
<li><code>bit</code>：推导为用户自定义长度的通用二态变量</li>
<li><code>byte</code>、<code>shortint</code>、<code>int</code>和<code>longint</code>：长度分别为8比特、16比特、32比特和64比特的二态变量</li>
</ul>
<p><code>reg</code>和<code>integer</code>早已是Verilog标准的一部分，本文不再详细讨论。</p>
<p><code>logic</code>严格意义上不能算是变量类型，但是在绝大多数上下文中，它通常被推导为<code>reg</code>类型。因此它可以被用于替代<code>reg</code>，使语言推导出变量。</p>
<p><code>byte</code>、<code>shortint</code>、<code>int</code>和<code>longint</code>只可用于存储二态值。综合会将其视作具有相同向量长度的四态<code>reg</code>变量。<strong>注意：</strong> 由于综合过程不回为耻二态的行为，因此可能会存在仿真和综合后功能不匹配的风险。一个潜在的区别是，二态变量在综合中每个比特的初始值总是0，而综合实现时每个比特可能是0也可能是1。</p>
<ul>
<li><strong>建议：</strong> 在绝大多数声明中使用<code>logic</code>，使语言基于上下文自动推导该声明的具体类型。避免在RTL模型中使用二态类型。这些类型可能会掩盖某些设计问题（见Sutherland<sup class="footnote-ref"><a href="#fn9" id="fnref9">[9]</a></sup>），而且可能会导致仿真和综合的不匹配。一个例外是在<code>for</code>循环中使用<code>int</code>变量作为迭代器。</li>
</ul>
<h4 id="2-4-向量声明（压缩数组）">2.4 向量声明（压缩数组）</h4>
<p>向量由方括号内明确的比特范围声明，后面跟随向量名。范围的声明形式为<code>[most-significant_bit_number : least-significant_bit_number]</code>。其中最高有效位（msb）和最低有效位（lsb）可以是任何数字，最高有效位可以是二者间最大或最小的数字。</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">wire</span>  [<span class="number">31</span>:<span class="number">0</span>] a;   <span class="comment">// 32位向量，小端序</span></span><br><span class="line"><span class="keyword">logic</span> [<span class="number">1</span>:<span class="number">32</span>] b;   <span class="comment">// 32位向量，大端序</span></span><br></pre></td></tr></table></figure>
<p>向量的声明、位选以及部分选择（多比特选择）一直是Verilog标准的一部分，且可综合。Verilog-2001新增了对变量的部分选择，同样可综合。</p>
<p>SystemVerilog称向量为<em>压缩数组</em>，以表示向量是有多个连续存储的比特构成的数组。其中一个重要改进是，SystemVerilog允许使用多个范围声明将向量划分为多个子域。例如：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">logic</span> [<span class="number">3</span>:<span class="number">0</span>][<span class="number">7</span>:<span class="number">0</span>] a;   <span class="comment">// 32比特向量，划分为4个8比特的子域</span></span><br><span class="line"></span><br><span class="line">a[<span class="number">2</span>] = <span class="number">8</span>’hFF;         <span class="comment">// 对子域2赋值</span></span><br><span class="line">a[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">1</span>’b1;       <span class="comment">// 选择子域1中的单个比特</span></span><br></pre></td></tr></table></figure>
<p>多维压缩数组及其选择操作是可综合的。在设计中需要频繁访问某个向量的子域时，该特性会十分有用。这一特性会很有用。例如在上面的例子中，这一特性就使得我们能够更加容易地从32比特的向量中选择字节。</p>
<h4 id="2-5-数组（非压缩数组）">2.5 数组（非压缩数组）</h4>
<p>SystemVerilog允许为线网类型、变量类型和用户定义类型（见2.6节）声明一维或多维数组。数组的维度声明在数组名之后。例如：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">logic</span> [<span class="number">7</span>:<span class="number">0</span>] LUT [<span class="number">0</span>:<span class="number">255</span>];              <span class="comment">// 256字节的一维数组</span></span><br><span class="line"><span class="keyword">logic</span> [<span class="number">7</span>:<span class="number">0</span>] RGB [<span class="number">0</span>:<span class="number">15</span>][<span class="number">0</span>:<span class="number">15</span>][<span class="number">0</span>:<span class="number">15</span>];   <span class="comment">// 多字节的三维数组</span></span><br></pre></td></tr></table></figure>
<p>使用索引访问数组中的元素：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">data = LUT[<span class="number">7</span>];          <span class="comment">// 访问索引为7的字节</span></span><br><span class="line">RGB[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">8</span>’h1A;   <span class="comment">// 为索引为0, 0, 0的字节赋值</span></span><br></pre></td></tr></table></figure>
<p>Verilog的数组和选择操作时可综合的。</p>
<p>SystemVerilog对Verilog数组进行了多个方面的扩展，其中有一些对复杂设计建模非常重要。这些将在下文中讨论。</p>
<h5 id="2-5-1-C语言风格的数组声明">2.5.1 C语言风格的数组声明</h5>
<p>Verilog数组由数组的地址范围声明，语法是<code>[first_addr : last_addr]</code>，如<code>[0:255]</code>。SystemVerilog则允许使用和C语言相同的方式，只声明数组的大小。如：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">logic</span> [<span class="number">7</span>:<span class="number">0</span>] LUT [<span class="number">256</span>];          <span class="comment">// 256字节的一维数组</span></span><br><span class="line"><span class="keyword">logic</span> [<span class="number">7</span>:<span class="number">0</span>] RGB [<span class="number">16</span>][<span class="number">16</span>][<span class="number">16</span>];   <span class="comment">// 多个字节构成的三维数组</span></span><br></pre></td></tr></table></figure>
<p>当使用这种语法是，数组寻址总是从0开始，结束于数组的大小减一。这个方便的小改动是可综合的。</p>
<h5 id="2-5-2-数组复制">2.5.2 数组复制</h5>
<p>Verilog只允许在单次操作中访问一个数组元素。如果要拷贝一个数组，则需要使用循环遍历数组的每个元素。SystemVerilog则允许通过单个语句拷贝数组，无论是整个数组还是数组的一部分都可以如此操作，例如：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">logic</span> [<span class="number">31</span>:<span class="number">0</span>] big_array    [<span class="number">0</span>:<span class="number">255</span>];  <span class="comment">// array with 256 32-bit elements</span></span><br><span class="line"><span class="keyword">logic</span> [<span class="number">31</span>:<span class="number">0</span>] small_array  [<span class="number">0</span>:<span class="number">15</span>];   <span class="comment">// array with 16 32-bit elements assign</span></span><br><span class="line"></span><br><span class="line">small_array = big_array[<span class="number">16</span>:<span class="number">31</span>];     <span class="comment">// copy 16 elements of big_array</span></span><br></pre></td></tr></table></figure>
<p>数组拷贝要求操作数具有相同的维度，以及每个维度上操作的元素数量相同。每个元素的位宽也必须相同，或者是兼容的数据类型。该操作是可综合的，也可以有效降低将块数据移动到其他数组的设计的复杂度。</p>
<h5 id="2-5-3-将值列表赋值给数组">2.5.3 将值列表赋值给数组</h5>
<p>数组的全部或者多个元素可以由<code>&#123;&#125;</code>包裹的值列表（list of values）赋值。该列表中的元素可以是独立的数组元素，也可以是数组的默认值。</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">logic</span> [<span class="number">7</span>:<span class="number">0</span>] a, b, c;</span><br><span class="line"><span class="keyword">logic</span> [<span class="number">7</span>:<span class="number">0</span>] d_array [<span class="number">0</span>:<span class="number">3</span>];                      <span class="comment">// array with 4 32-bit elements</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">always_ff</span> @(<span class="keyword">posedge</span> clock <span class="keyword">or</span> <span class="keyword">negedge</span> rstN)</span><br><span class="line">  <span class="keyword">if</span> (!rstN)  d_array &lt;= ’&#123;<span class="keyword">default</span>:<span class="number">0</span>&#125;;          <span class="comment">// reset all elements of the array</span></span><br><span class="line">  <span class="keyword">else</span>        d_array &lt;= ’&#123;<span class="number">8</span>’h00, c, b, a&#125;;     <span class="comment">// load the array</span></span><br></pre></td></tr></table></figure>
<p>数组列表是可综合的。数组的维数和数组列表中值得数量必须匹配。数组中每个元素的位宽必须与列表中的每个值相同。</p>
<h5 id="2-5-4-将数组传递给模块端口、任务和函数">2.5.4 将数组传递给模块端口、任务和函数</h5>
<p>可以为数组中的多个元素赋值的能力也使得使用数组作为模块端口，以及任务或者函数的入参成为可能。下面的例子定义了一个用于表示8*256，位宽为32比特的二维数组的用户自定义类型，然后将其作为函数的入参和返回值，以及模块端口。2.6节将会讨论用户自定义类型的更多细节，4.1节将会讨论用户自定义类型的合适用法。</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">logic</span> [<span class="number">31</span>:<span class="number">0</span>] d_array_t [<span class="number">0</span>:<span class="number">7</span>][<span class="number">0</span>:<span class="number">255</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> block_data (<span class="keyword">input</span> d_array_t d_in,            <span class="comment">// input is an array</span></span><br><span class="line">                   <span class="keyword">output</span> d_array_t q_out,          <span class="comment">// output is an array</span></span><br><span class="line">                   <span class="keyword">input</span> <span class="keyword">logic</span> clock, rstN);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> d_array_t transform (<span class="keyword">input</span> d_array_t d); <span class="comment">// input is an array</span></span><br><span class="line">    <span class="comment">// ... perform operations on all elements of d</span></span><br><span class="line">    <span class="keyword">return</span> d; <span class="comment">// return is an array</span></span><br><span class="line">  <span class="keyword">endfunction</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">always_ff</span> @(<span class="keyword">posedge</span> clock <span class="keyword">or</span> <span class="keyword">negedge</span> rstN)</span><br><span class="line">  <span class="keyword">if</span> (!rstN) q_out &lt;= ’&#123;<span class="keyword">default</span>:<span class="number">0</span>&#125;;                 <span class="comment">// reset entire q_out array</span></span><br><span class="line">  <span class="keyword">else</span>       q_out &lt;= transform(d_in);              <span class="comment">// transform and store entire array</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<p>注意SystemVerilog要求通过模块端口或者任务、函数参数传递的值必须拥有相同的维数，它们的每个元素必须拥有相同的向量大小和兼容类型。</p>
<h5 id="2-5-5-数组查询系统函数">2.5.5 数组查询系统函数</h5>
<p>SystemVerilog提供了丰富的系统函数，使操作非硬编码大小的数组变得更容易。可综合的数组查询函数有：<code>$left()</code>、<code>$right()</code>、<code>$low()</code>、<code>$high()</code>、<code>$increment()</code>、<code>$size()</code>、<code>$dimensions()</code>以及<code>$unpacked_dimensions()</code>。下面是一些简单使用它们的例子：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">logic</span> [<span class="number">31</span>:<span class="number">0</span>] d_array_t [<span class="number">0</span>:<span class="number">15</span>][<span class="number">0</span>:<span class="number">15</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> d_array_t transform (<span class="keyword">input</span> d_array_t d);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="built_in">$low</span>(d,<span class="number">1</span>); i &lt;= <span class="built_in">$high</span>(d,<span class="number">1</span>); i++) <span class="keyword">begin</span>: outer_loop</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="built_in">$low</span>(d,<span class="number">2</span>); j &lt;= <span class="built_in">$high</span>(d,<span class="number">2</span>); j++) <span class="keyword">begin</span>: inner_loop</span><br><span class="line">      <span class="comment">// ... perform some sort of operation on each element of d</span></span><br><span class="line">    <span class="keyword">end</span>: inner_loop</span><br><span class="line">  <span class="keyword">end</span>: outer_loop</span><br><span class="line">  <span class="keyword">return</span> d; <span class="comment">// function return is an array</span></span><br><span class="line"><span class="keyword">endfunction</span></span><br></pre></td></tr></table></figure>
<p><strong>注意</strong>：此例可以使用<code>foreach</code>循环进行更进一步的简化。不幸的是，<code>foreach</code>尚且不被DC和Synplify-Pro支持，关于它的更多细节，详见12.2节。</p>
<h5 id="2-5-6-不可综合的数组改进">2.5.6 不可综合的数组改进</h5>
<p>SystemVerilog以其他几种不可综合的方式扩展了Verilog数组。这些改进包括<code>foreach</code>迭代器循环、数组操作函数、数组定位器函数、数组排序函数以及数组位流转换等。</p>
<h4 id="2-6-用户定义类型">2.6 用户定义类型</h4>
<p>原生Verilog语言只有内建数据类型。SystemVerilog允许设计和验证工程师创建新的，用户自定义的数据类型，且变量和线网都可以由用户自定义类型声明。如果声明中没有明确指定类型，那么它们总是被假定为变量类型。可综合的用户自定义类型如下：</p>
<ul>
<li><code>enum</code>：具有合法值枚举列表的变量或网络，见2.6.1节；</li>
<li><code>struct</code>：组合多个线网或者变量的结构体，见2.6.2节；</li>
<li><code>union</code>：可以分时容纳不同类型数据的变量，见2.6.3节；</li>
<li><code>typedef</code>：类型定义，见2.6.4节。</li>
</ul>
<h5 id="2-6-1-枚举类型">2.6.1 枚举类型</h5>
<p>枚举类型允许变量和线网被具名值（named valus）的特殊集合定义。本文仅介绍枚举类型的可综合方面。声明枚举类型的基本语法是：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="comment">// a variable that has 3 legal values</span></span><br><span class="line"><span class="keyword">enum</span> &#123;WAITE, LOAD, DONE&#125; State;</span><br></pre></td></tr></table></figure>
<p>枚举类型一般拥有一个基础数据类型，默认情况下是<code>int</code>（二态值，32比特）。上例中，<code>State</code>是<code>int</code>类型，而<code>WAITE</code>、<code>LOAD</code>、<code>DONE</code>是32比特的<code>int</code>值。枚举列表中的标签均为常量且顺序递增。一般情况下，第一个标签值为逻辑上的0，此后的标签依次递增1。因此，上例中的<code>WAITE</code>值为0，<code>LOAD</code>值为1，而<code>DONE</code>值为2。</p>
<p>设计者可以明确声明基础类型，以允许枚举类型使用特殊的硬件模型。设计者也可以为枚举列表中的部分或者全部标签显式声明特定的值。例如：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// Two 3-bit, 4-state enumerated variables with one-hot values</span></span><br><span class="line"><span class="keyword">enum</span> <span class="keyword">logic</span> [<span class="number">2</span>:<span class="number">0</span>] &#123;</span><br><span class="line">  WAITE = <span class="number">3</span>’b001,</span><br><span class="line">  LOAD  = <span class="number">3</span>’b010,</span><br><span class="line">  DONE  = <span class="number">3</span>’b100</span><br><span class="line">&#125; State, NextState;</span><br></pre></td></tr></table></figure>
<p>相对于内建的变量和线网类型，枚举类型拥有更健壮的检查规则：</p>
<ul>
<li>枚举列表中的每个标签的值必须是唯一的；</li>
<li>变量值的大小和标签的值必须相同；</li>
<li>枚举变量仅可通过以下方式赋值：
<ul>
<li>枚举列表中的标签</li>
<li>拥有相同枚举类型的另一个变量</li>
</ul>
</li>
</ul>
<p>这些健壮的规则使得枚举类型相比传统的Verilog提供了巨大的优势。下面的两个例子对比了分别由Verilog和SystemVerilog建模的简单状态机。这两个模型均有数个编码错误，注意看注释。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// Names for state machine states (one-hot encoding)</span></span><br><span class="line"><span class="keyword">parameter</span> [<span class="number">2</span>:<span class="number">0</span>] WAITE=<span class="number">3&#x27;b001</span>, LOAD=<span class="number">3&#x27;b010</span>, DONE=<span class="number">3&#x27;b001</span>; <span class="comment">// FUNCTIONAL BUG</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Names for mode_control output values</span></span><br><span class="line"><span class="keyword">parameter</span> [<span class="number">1</span>:<span class="number">0</span>] READY=<span class="number">3&#x27;b101</span>, SET=<span class="number">3&#x27;b010</span>, GO=<span class="number">3&#x27;b110</span>;    <span class="comment">// FUNCTIONAL BUG</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// State and next state variables</span></span><br><span class="line"><span class="keyword">reg</span> [<span class="number">2</span>:<span class="number">0</span>] state, next_state, mode_control;</span><br><span class="line"></span><br><span class="line"><span class="comment">// State Sequencer</span></span><br><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> clock <span class="keyword">or</span> <span class="keyword">negedge</span> resetN)</span><br><span class="line">  <span class="keyword">if</span> (!resetN) state &lt;= <span class="number">0</span>;         <span class="comment">// FUNCTIONAL BUG</span></span><br><span class="line">  <span class="keyword">else</span>         state &lt;= next_state;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Next State Decoder (sequentially cycle through the three states)</span></span><br><span class="line"><span class="keyword">always</span> @(state)</span><br><span class="line">  <span class="keyword">case</span> (state)</span><br><span class="line">    WAITE: next_state = state + <span class="number">1</span>; <span class="comment">// DANGEROUS CODE</span></span><br><span class="line">    LOAD : next_state = state + <span class="number">1</span>; <span class="comment">// FUNCTIONAL BUG</span></span><br><span class="line">    DONE : next_state = state + <span class="number">1</span>; <span class="comment">// FUNCTIONAL BUG</span></span><br><span class="line">  <span class="keyword">endcase</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Output Decoder</span></span><br><span class="line"><span class="keyword">always</span> @(state)</span><br><span class="line">  <span class="keyword">case</span> (state)</span><br><span class="line">    WAITE: mode_control = READY;</span><br><span class="line">    LOAD : mode_control = SET;</span><br><span class="line">    DONE : mode_control = DONE;   <span class="comment">// FUNCTIONAL BUG</span></span><br><span class="line">  <span class="keyword">endcase</span></span><br></pre></td></tr></table></figure>
<p>上例中的六个问题均是合法可综合的，且仿真也可以正常编译和运行。如果顺利的话，验证代码也许可以捕捉到功能问题。综合过程中也许会对一些编码错误提出警告，但一些错误仍会在最终的门级实现中保留。</p>
<p>下面的例子展示了同样的编码错误，但是使用枚举类型替代了Verilog中的<code>parameter</code>和<code>reg</code>类型（该例也使用了部分后文介绍的SystemVerilog结构）。注释显示，每个Verilog中被认为是功能问题的地方都变成了语法错误 —— 编译器捕获了这些错误，而不是不得不检测、调试和重新验证这些问题。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> bad_fsm_systemverilog_style (...); <span class="comment">// only relevant code shown</span></span><br><span class="line"><span class="keyword">enum</span> <span class="keyword">logic</span> [<span class="number">2</span>:<span class="number">0</span>] &#123;WAITE=<span class="number">3&#x27;b001</span>, LOAD=<span class="number">3&#x27;b010</span>, DONE=<span class="number">3&#x27;b001</span>&#125; <span class="comment">// SYNTAX ERROR</span></span><br><span class="line">                  state, next_state;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="keyword">logic</span> [<span class="number">1</span>:<span class="number">0</span>] &#123;READY=<span class="number">3&#x27;b101</span>, SET=<span class="number">3&#x27;b010</span>, GO=<span class="number">3&#x27;b110</span>&#125;    <span class="comment">// SYNTAX ERROR</span></span><br><span class="line">                  mode_control;</span><br><span class="line"></span><br><span class="line"><span class="comment">// State Sequencer</span></span><br><span class="line"><span class="keyword">always_ff</span> @(<span class="keyword">posedge</span> clock <span class="keyword">or</span> <span class="keyword">negedge</span> resetN)</span><br><span class="line">  <span class="keyword">if</span> (!resetN) state &lt;= <span class="number">0</span>; <span class="comment">// SYNTAX ERROR</span></span><br><span class="line">  <span class="keyword">else</span> state &lt;= next_state;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Next State Decoder (sequentially cycle through the three states)</span></span><br><span class="line"><span class="keyword">always_comb</span></span><br><span class="line">  <span class="keyword">case</span> (state)</span><br><span class="line">    WAITE: next_state = state + <span class="number">1</span>; <span class="comment">// SYNTAX ERROR</span></span><br><span class="line">    LOAD : next_state = state + <span class="number">1</span>; <span class="comment">// SYNTAX ERROR</span></span><br><span class="line">    DONE : next_state = state + <span class="number">1</span>; <span class="comment">// SYNTAX ERROR</span></span><br><span class="line">  <span class="keyword">endcase</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Output Decoder</span></span><br><span class="line"><span class="keyword">always_comb</span></span><br><span class="line">  <span class="keyword">case</span> (state)</span><br><span class="line">    WAITE: mode_control = READY;</span><br><span class="line">    LOAD : mode_control = SET;</span><br><span class="line">    DONE : mode_control = DONE;   <span class="comment">// SYNTAX ERROR</span></span><br><span class="line">  <span class="keyword">endcase</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<p>注意：DC无法捕获到上例中的第二个语法错误，但是VCS可以。</p>
<p>SystemVerilog也提供了数个和枚举类型配合使用的方法。可综合的方法有：<code>.first</code>、<code>.last</code>、<code>.next</code>，<code>.prev</code>以及<code>.num</code>。枚举类型的排序基于其声明的顺序（而非标签的值）。上例中的循环逐次状态解码就可以使用这些方法进行简化：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">always_comb</span></span><br><span class="line">  next_state = state<span class="variable">.next</span>;  <span class="comment">// transitions from WAITE to LOAD, from LOAD to</span></span><br><span class="line">                            <span class="comment">// DONE, and from DONE back to WAITE</span></span><br></pre></td></tr></table></figure>
<p>尽管枚举方法可以在某些情境下简化代码，但是在真实的设计应用它们依然是有某种程度的限制的。本文作者认为使用枚举标签赋值是更好的代码代码风格，而非使用枚举方法。使用枚举标签可以使代码更好地进行自注释，以及提供更灵活的状态机分支。</p>
<p><strong>注意</strong>：本文写作时，Synplify-Pro尚不支持枚举方法。</p>
<ul>
<li><strong>SystemVerilog优势之三</strong>：枚举类型可以预防一些难以检测和调试的编码错误！在变量和线网只拥有数个合法值得时候，无论何时都应该优先选择枚举类型。</li>
</ul>
<h5 id="2-6-2-结构体">2.6.2 结构体</h5>
<p>SystemVerilog的结构体（Structure）提供了一种将多个变量置于一个公共名称的机制。结构体使可综合的，前提是结构体中的成员的类型是可综合的。</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> &#123;</span><br><span class="line">  <span class="keyword">logic</span> [<span class="number">31</span>:<span class="number">0</span>] source_address;</span><br><span class="line">  <span class="keyword">logic</span> [<span class="number">31</span>:<span class="number">0</span>] destination_address;</span><br><span class="line">  <span class="keyword">logic</span> [<span class="number">63</span>:<span class="number">0</span>] data;</span><br><span class="line">  <span class="keyword">logic</span> [<span class="number">3</span>:<span class="number">0</span>] ecc;</span><br><span class="line">&#125; packet;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>使用点操作符<code>.</code>可以单独访问结构体中的各个成员：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">packet<span class="variable">.source_address</span> = <span class="number">32&#x27;h0000dead</span>;</span><br></pre></td></tr></table></figure>
<p>更有用的是，结构体可以作为一个整体读写，如果两个结构体实例的定义相同，则它们可以整体拷贝。这个操作需要使用在2.6.4节介绍的<code>typedef</code>。使用<code>typedef</code>定义的结构体也可以作为一个整体，传递给模块端口、认为或者函数。</p>
<p>结构体中的所有成员可以使用由<code>&#123;&#125;</code>的值列表赋值，该列表可以包含每个成员的值，或者任意成员的默认值。</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">always_ff</span> @(<span class="keyword">posedge</span> clock <span class="keyword">or</span> <span class="keyword">negedge</span> rstN)</span><br><span class="line">  <span class="keyword">if</span> (!rstN) packet &lt;= ’&#123;<span class="keyword">default</span>:<span class="number">0</span>&#125;; <span class="comment">// reset all members of packet</span></span><br><span class="line">  <span class="keyword">else</span> packet &lt;= ’&#123;old_addr, new_addr, data_in, ecc_func(data_in)&#125;;</span><br></pre></td></tr></table></figure>
<p>默认情况下，结构体的成员以软件工具认为最佳的任何方式存储。大多数时候，这将会产出最佳的仿真和综合质量。设计者可以通过把结构体声明为<code>packed</code>以控制成员的存储方式。声明为<code>packed</code>的结构体将会连续存储所有的成员，此时第一个成员将会位于存储的最左侧，即LSB模式。和<code>packed union</code>（见下节）联合使用时，这是非常有用的特性。</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="keyword">packed</span> &#123; <span class="comment">// members will be stored contiguously</span></span><br><span class="line">  <span class="keyword">logic</span> [ <span class="number">1</span>:<span class="number">0</span>] parity;</span><br><span class="line">  <span class="keyword">logic</span> [<span class="number">63</span>:<span class="number">0</span>] data;</span><br><span class="line">&#125; data_word;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>SystemVerilog优势之四</strong>：使用结构体将所有相关变量聚拢到一起，这个集合可以被整体传输或赋值，这可以有效减少代码行数以及保证一致性。仅在需要在<code>union</code>中使用结构体的时候将其声明为<code>packed</code>。</li>
</ul>
<h5 id="2-6-3-联合体">2.6.3 联合体</h5>
<p>联合体（Union）允许一块单独的存储空间表现出多种存储格式。SystemVerilog拥有三种类型的联合体：简单联合体（Simple Union）、压缩联合体（Packed Union）和标记联合体（Tagged Union）。只有压缩联合体可以被综合。压缩联合体要求所有成员都是具有相同位数的压缩类型。压缩类型包括位向量（压缩数组）、整数类型和压缩结构体。由于在压缩联合体中所有成员的大小相同，因此将数据写入联合的一个成员（格式），然后从另一个成员读取数据（的操作）是合法的。</p>
<p>下面的例子展示了一个64比特的寄存器，它可以存储一个数据包或者指令包：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">union</span> <span class="keyword">packed</span> &#123;</span><br><span class="line">  <span class="keyword">struct</span> <span class="keyword">packed</span> &#123;</span><br><span class="line">    <span class="keyword">logic</span> [<span class="number">31</span>:<span class="number">0</span>] data;</span><br><span class="line">    <span class="keyword">logic</span> [<span class="number">31</span>:<span class="number">0</span>] address;</span><br><span class="line">  &#125; data_packet;</span><br><span class="line">  <span class="keyword">struct</span> <span class="keyword">packed</span> &#123;</span><br><span class="line">    <span class="keyword">logic</span> [<span class="number">31</span>:<span class="number">0</span>] data;</span><br><span class="line">    <span class="keyword">logic</span> [<span class="number">31</span>:<span class="number">0</span>] operation;</span><br><span class="line">  &#125; instruction_packet;</span><br><span class="line">&#125; packet_u;</span><br><span class="line"></span><br><span class="line"><span class="keyword">always_ff</span> @(<span class="keyword">posedge</span> clock <span class="keyword">or</span> <span class="keyword">negedge</span> rstN)</span><br><span class="line">  <span class="keyword">if</span> (!rstN)                packet_u &lt;= &#123;’<span class="number">0</span>, ’<span class="number">0</span>&#125;; <span class="comment">// reset</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (op_type == DATA) packet_u<span class="variable">.data_packet</span> &lt;= &#123;d_in, addr&#125;;</span><br><span class="line">  <span class="keyword">else</span>                      packet_u<span class="variable">.instruction_packet</span> &lt;= &#123;d_in, instr&#125;;</span><br></pre></td></tr></table></figure>
<p>上例最后三行中的赋值语句把两个值拼接后赋值给结构体<code>data_struct</code>或者<code>instruction_packet</code>。由于这两个结构体都声明为<code>packed</code>，因此它是合法且功能正确的。</p>
<ul>
<li>*<strong>注意</strong>：*将值列表赋值给结构体是合法可综合的，也是推荐的代码风格，见<a href="#21-%E5%80%BC%E9%9B%86">2.1节</a>，但DC并不支持将值列表赋值给联合体中的结构体成员。</li>
</ul>
<h5 id="2-6-4-类型定义typedef">2.6.4 类型定义<code>typedef</code></h5>
<p>由内置类型和其他用户自定义类型构成的新的数据类型可以像C语言一样使用<code>typedef</code>，例如：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">logic</span> [<span class="number">31</span>:<span class="number">0</span>] bus64_t; <span class="comment">// 64-bit bus</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;              <span class="comment">// typed structure</span></span><br><span class="line">  <span class="keyword">logic</span> [ <span class="number">1</span>:<span class="number">0</span>] parity;</span><br><span class="line">  <span class="keyword">logic</span> [<span class="number">63</span>:<span class="number">0</span>] data;</span><br><span class="line">&#125; data_t;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> <span class="keyword">logic</span> &#123;FALSE=<span class="number">1</span>’b0, TRUE=<span class="number">1</span>’b1&#125; bool_t;</span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> D (<span class="keyword">input</span> data_t a, b,</span><br><span class="line">          <span class="keyword">output</span> bus64_t result,</span><br><span class="line">          <span class="keyword">output</span> bool_t aok );</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<p>SystemVerilog还提供了一种名为<code>package</code>的结构用于封装<code>typedef</code>和其他定义。关于在综合中使用<code>package</code>的更多细节见<a href="#41-%E5%8C%85">4.1节</a>。</p>
<ul>
<li>
<p><strong>SystemVerilog优势之五</strong>：用户自定义的类型，即便是最简单的向量类型别名，也可以保证该类型在整个项目中的一致性。使用用户自定义类型可以避免类型和大小的不匹配。</p>
</li>
<li>
<p><em><strong>推荐</strong>：</em> 尽可能使用<code>typedef</code>。即使是项目中一个特定大小的向量类型，例如地址或数据向量，也应该被定义为一种用户自定义类型。所有的<code>typedef</code>应该被封装在<code>package</code>中。</p>
</li>
</ul>
<h3 id="3-参数化建模">3 参数化建模</h3>
<p>Verilog具有使用参数和参数重定义使得模型可配置和可扩展的能力。参数化模型也是Verilog标准的一部分，本文不予讨论。</p>
<p>SystemVerilog扩展了Verilog中参数的定义和重定义，以允许参数化的数据类型，例如：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> adder #(<span class="keyword">parameter</span> <span class="keyword">type</span> dtype = <span class="keyword">logic</span> [<span class="number">0</span>:<span class="number">0</span>]) <span class="comment">// 默认为1比特位宽</span></span><br><span class="line">              (<span class="keyword">input</span> dtype a, b,</span><br><span class="line">               <span class="keyword">output</span> dtype sum);</span><br><span class="line">  <span class="keyword">assign</span> sum = a + b;</span><br><span class="line"><span class="keyword">endmodule</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> top (</span><br><span class="line">  <span class="keyword">input</span> <span class="keyword">logic</span> [<span class="number">15</span>:<span class="number">0</span>] a, b,</span><br><span class="line">  <span class="keyword">input</span> <span class="keyword">logic</span> [<span class="number">31</span>:<span class="number">0</span>] c, d,</span><br><span class="line">  <span class="keyword">output</span> <span class="keyword">logic</span> [<span class="number">15</span>:<span class="number">0</span>] r1,</span><br><span class="line">  <span class="keyword">output</span> <span class="keyword">logic</span> [<span class="number">31</span>:<span class="number">0</span>] r2);</span><br><span class="line"></span><br><span class="line">  adder <span class="variable">#(.dtype(logic [15:0]))         i1 (a, b, r1)</span>; <span class="comment">// 16位加法器</span></span><br><span class="line">  adder <span class="variable">#(.dtype(logic signed [31:0]))  i2 (c, c, r2)</span>; <span class="comment">// 32位有符号加法器</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<p>参数化数据类型是可综合的。注意SystemVerilog-2009使关键字<code>parameter</code>在模块参数列表<code>#(...)</code>中成为可选项，但是DC依然要求该关键字。</p>
<h3 id="4-共享声明空间-——-packages和-unit">4 共享声明空间 —— <code>packages</code>和<code>$unit</code></h3>
<h4 id="4-1-包">4.1 包</h4>
<p>原始的Verilog标准中并没有共享的生命空间。每个模块包含所有在此模块中使用的声明。这是Verilog的一个主要的局限性。如果相同的参数、任务或函数定义被多个模块需要，设计者必须采用笨拙而糟糕的方法，通常是配个编译器指令<code> `ifdef</code>和<code> `include</code>。SystemVerilog添加了一系列用户定义类型、面向对象的类定义以及随机约束，这使得缺少共享命名空间的问题成为了一个严峻的问题。</p>
<p>SystemVerilog添加了用户自定义包，以克服Verilog的这个缺点。包提供了一个可以被多个设计模块，也包括验证代码，引用的声明空间。可以在包中出现的可综合项目如下：</p>
<ul>
<li><code>parameter</code>和<code>localparam</code>常量的定义</li>
<li><code>const</code>变量定义</li>
<li><code>typedef</code>用户自定义变量</li>
<li>完全自动化的<code>task</code>和<code>function</code>定义</li>
<li>引用其他包的<code>import</code>语句</li>
<li>用于包链的<code>export</code>语句</li>
</ul>
<p>一个包的简单示例如下：</p>
 <figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> alu_types;</span><br><span class="line">  <span class="keyword">localparam</span> DELAY = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">logic</span> [<span class="number">31</span>:<span class="number">0</span>] bus32_t;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">logic</span> [<span class="number">63</span>:<span class="number">0</span>] bus64_t;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">enum</span> <span class="keyword">logic</span> [<span class="number">3</span>:<span class="number">0</span>] &#123;ADD, SUB, ...&#125; opcode_t;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">    bus32_t i0, i1;</span><br><span class="line">    opcode_t opcode;</span><br><span class="line">  &#125; instr_t;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> <span class="keyword">automatic</span> <span class="keyword">logic</span> parity_gen(<span class="keyword">input</span> d);</span><br><span class="line">    <span class="keyword">return</span> ^d;</span><br><span class="line">  <span class="keyword">endfunction</span></span><br><span class="line"><span class="keyword">endpackage</span></span><br></pre></td></tr></table></figure>
<p>注意：</p>
<ul>
<li>在包中定义了的<code>parameter</code>不可以被重定义，<code>localparam</code>同理</li>
<li>综合要求包中定义的<code>task</code>和<code>function</code>必须声明为<code>automatic</code></li>
</ul>
<h5 id="4-1-1-引用包定义">4.1.1 引用包定义</h5>
<p>包内的定义可以被设计块（例如<code>module</code>和<code>interface</code>）通过以下三种方式引用：</p>
<ul>
<li>显式包引用</li>
<li>显式<code>import</code>语句</li>
<li>通配<code>import</code>语句</li>
</ul>
<p>通过<code>packages::item</code>的方式，可以对包内定义的条目进行<em>显式引用</em>。例如：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> alu</span><br><span class="line">  (<span class="keyword">input</span> alu_types::instr_t instruction,  <span class="comment">// 端口列表中的引用</span></span><br><span class="line">   <span class="keyword">output</span> alu_types::bus64_t result );</span><br><span class="line">  alu_types::bus64_t temp;                <span class="comment">// 模块内部的引用</span></span><br><span class="line">  ...</span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<p>对包内条目的显式引用不会使之在该模块内其他位置可见。因此每次使用该定义时，都必须显式进行引用。</p>
<p>通过<code>import</code>语句<em>显式导入</em>包内条目。条目一旦被导入，即可在该模块中被多次引用。如：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> alu</span><br><span class="line">  <span class="keyword">import</span> alu_types::bus64_t;</span><br><span class="line">  (<span class="keyword">input</span> alu_types::instr_t instruction, <span class="comment">// 显式引用</span></span><br><span class="line">   <span class="keyword">output</span> bus64_t result );              <span class="comment">// bus64_t已被导入</span></span><br><span class="line">  bus64_t temp;                          <span class="comment">// bus64_t已被导入</span></span><br><span class="line">  ...</span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<p><em>通配导入</em>使用<code>*</code>表示包内所有的条目。通配导入使得包内所有条目在模块中均可见。如：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> alu</span><br><span class="line">  <span class="keyword">import</span> alu_types::*;</span><br><span class="line">  (<span class="keyword">input</span> instr_t instruction,   <span class="comment">// instr_t已被导入</span></span><br><span class="line">   <span class="keyword">output</span> bus64_t result );     <span class="comment">// bus64_t已被导入</span></span><br><span class="line">  bus64_t temp;                 <span class="comment">// bus64_t已被导入</span></span><br><span class="line">  ...</span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>SystemVerilog优势之六：</strong> 包可以消除冗余代码，消除不同设计块之间可能存在不匹配的风险，以及减少维护冗余代码的难度。</li>
</ul>
<p><strong>建议：</strong> 现在开始使用包！包提供了干净、简单的方法在整个项目中重用任务、函数以及用户定义类型。</p>
<h5 id="4-1-2-import语句的位置">4.1.2 <code>import</code>语句的位置</h5>
<p><code>import</code>语句的位置在前两个例子中是很重关于的。为了在端口列表中引用包内条目的定义，该条目必须在引用前被导入。在SystemVerilog-2005中，<code>import</code>语句只能出现在端口列表之后，这太晚了。SystemVerilog-2009允许<code>import</code>语句出现在端口列表之前，甚至是参数列表之前。这一增强已经发布了三年之久，但是Synopsys仍没有实现这一微小而重要的改进。</p>
<p>注意：DC支持在端口列表前放置<code>import</code>语句，但是需要手动开启<code>set hdlin_sverilog_std_2009</code>。截至本文撰写时，Synplify-Pro仍不支持这一特性。</p>
<h5 id="4-1-3-将一个包导入另一个包内">4.1.3 将一个包导入另一个包内</h5>
<p>一个包可以导入或者引用来自其他的包的定义。将包导入其他的包也是可综合的。SystemVerilog也允许包链（Package Chaining），一种简化包间引用的方法。</p>
<p><em>注意：</em> DC尚不支持包链。关于包链的更多信息，参考第12.6节。</p>
<h5 id="4-1-4-包的编译顺序">4.1.4 包的编译顺序</h5>
<p>SystemVerilog的语法要求包内条目在被引用前必须先被编译。这意味着编译时存在文件依赖顺序，同时也意味着引用了包内条目的模块无法被单独编译 —— 包必须在模块之前被编译（或者预编译，如果工具支持增量编译的话）。</p>
<h4 id="4-2-unit">4.2 <code>$unit</code></h4>
<p>在包被添加到标准之前，SystemVerilog还提供了一种不同的机制用于创建多模块共享的定义，即<code>$unit</code>，一个伪全局命名空间。任何在具名声明空间外定义的声明都属于<code>$unit</code>包。在下面的例子中，<code>bool_t</code>的定义在两模块之外，因此它属于<code>$unit</code>声明空间。</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> <span class="keyword">bit</span> &#123;FALSE, TRUE&#125; bool_t;</span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> alu (...);</span><br><span class="line">  bool_t success_flag;</span><br><span class="line">  ...</span><br><span class="line"><span class="keyword">endmodule</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> decoder (...);</span><br><span class="line">  bool_t a_ok;</span><br><span class="line">  ...</span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<p><code>$unit</code>可以包含的用户定义的类型与具名包是相同的，综合限制也相同。</p>
<p><strong>注意：</strong> <code>$unit</code>是一个危险的共享命名空间，充斥着各种风险。简单来说，它带来的风险如下：</p>
<ol>
<li><code>$unit</code>中的定义可以散落在多个文件中，使其维护如噩梦一般</li>
<li>当<code>$unit</code>中的定义分布在多个文件中时，这些文件必须以特定的顺序被编译，以保证每个定义在引用前都被编译</li>
<li>每次调用编译器都会开启一个新的<code>$unit</code>空间，它不共享其他空间内的声明。因此同时编译多个文件的编译器（如VCS）将看到多个<code>$unit</code>空间，而独立编译每个文件的编译器（如DC）将看到多个独立的<code>$unit</code>空间。</li>
<li>在同一个命名空间中多次定义相同的名字在SystemVerilog中是非法的。因此如果一个文件在<code>$unit</code>中定义了<code>bool_t</code>，而另一个文件也在<code>$unit</code>中定义了<code>bool_t</code>，并且这两个文件一起编译的话，就会发生编译错误或elaboration错误。</li>
<li>具名包可以被导入<code>$unit</code>，但是将同一个包多次导入同一命名空间是非法的</li>
</ol>
<p><strong>建议：应当完全避免使用<code>$unit</code>！</strong> 通过具名包共享定义可以有效避免<code>$unit</code>带来的风险。</p>
<hr class="footnotes-sep">
<section class="footnotes">
<ol class="footnotes-list">
<li id="fn1" class="footnote-item"><p>“1364-1995 IEEE Standard Verilog Hardware Description Language”, IEEE, Pascataway, New Jersey. Copyright 1995. ISBN:.1-55937-727-5 <a href="#fnref1" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn2" class="footnote-item"><p>“1364-2001 IEEE Standard Verilog Hardware Description Language”, IEEE, Pascataway, New Jersey. Copyright 2001. ISBN: 0-7381-2826-0. <a href="#fnref2" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn3" class="footnote-item"><p>“1364.1-2002 IEEE Standard for Verilog Register Transfer Level Synthesis”, IEEE, Pascataway, New Jersey.Copyright 2002. ISBN: 0-7381-3501-1. <a href="#fnref3" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn4" class="footnote-item"><p>“P1364-2005 Draft Standard for Verilog Hardware Description Language”, IEEE, Pascataway, New Jersey. Copyright 2005. ISBN: 0-7381-4850-4 <a href="#fnref4" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn5" class="footnote-item"><p>“1800-2005 IEEE Standard for SystemVerilog: Unified Hardware Design, Specification and Verification Language”, IEEE, Pascataway, New Jersey. Copyright 2005. ISBN: 0-7381-4811-3. <a href="#fnref5" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn6" class="footnote-item"><p>“1800-2009 IEEE Standard for SystemVerilog: Unified Hardware Design, Specification and Verification Language”, IEEE, Pascataway, New Jersey. Copyright 2009. ISBN: 978-0-7381-6129-7. <a href="#fnref6" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn7" class="footnote-item"><p>“1800-2012 IEEE Standard for System Verilog: Unified Hardware Design, Specification and Verification Language”, IEEE, Pascataway, New Jersey. Copyright 2013. ISBN: 978-0-7381-8110-3 (PDF), 978-0-7381-8111-0 (print). <a href="#fnref7" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn8" class="footnote-item"><p>Sutherland, “I’m Still in Love with My X!”, Design and Verification Conference (DVCon), San Jose, California, February 2013. <a href="#fnref8" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn9" class="footnote-item"><p>Sutherland, “I’m Still in Love with My X!”, Design and Verification Conference (DVCon), San Jose, California, February 2013. <a href="#fnref9" class="footnote-backref">↩︎</a></p>
</li>
</ol>
</section>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://blogs.stephen-zhang.cn">stephen zhang</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://blogs.stephen-zhang.cn/post/a706f59a/">https://blogs.stephen-zhang.cn/post/a706f59a/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow noreferrer" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://blogs.stephen-zhang.cn" target="_blank">Stephen Zhang's Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/HDL/">HDL</a><a class="post-meta__tags" href="/tags/Verilog/">Verilog</a><a class="post-meta__tags" href="/tags/SystemVerilog/">SystemVerilog</a></div><div class="post_share"><div class="addtoany"><div class="a2a_kit a2a_kit_size_32 a2a_default_style"><a class="a2a_button_twitter"></a><a class="a2a_button_wechat"></a><a class="a2a_button_sina_weibo"></a><a class="a2a_button_email"></a><a class="a2a_button_copy_link"></a><a class="a2a_dd" target="_blank" rel="noopener external nofollow noreferrer" href="https://www.addtoany.com/share"></a></div></div><script async="async" src="https://static.addtoany.com/menu/page.js"></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i>赞助</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="https://s2.loli.net/2022/04/17/dSevxc1pMP6CEnR.png" rel="external nofollow noreferrer" target="_blank"><img class="post-qr-code-img" src="https://s2.loli.net/2022/04/17/dSevxc1pMP6CEnR.png" alt="微信支付"/></a><div class="post-qr-code-desc">微信支付</div></li><li class="reward-item"><a href="https://s2.loli.net/2022/04/17/zilkjsBucpeWHZD.png" rel="external nofollow noreferrer" target="_blank"><img class="post-qr-code-img" src="https://s2.loli.net/2022/04/17/zilkjsBucpeWHZD.png" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/post/9f47efb9/" title="为ZeroTier搭建私有Planet Server"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">为ZeroTier搭建私有Planet Server</div></div></a></div><div class="next-post pull-right"><a href="/post/f46b60a4/" title="AXI-4接口规范浅析"><img class="cover" src="https://s2.loli.net/2023/11/08/VuivdDFQRPylhLe.png" onerror="onerror=null;src='/images/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">AXI-4接口规范浅析</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/post/f46b60a4/" title="AXI-4接口规范浅析"><img class="cover" src="https://s2.loli.net/2023/11/08/VuivdDFQRPylhLe.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-11-06</div><div class="title">AXI-4接口规范浅析</div></div></a></div></div></div><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="giscus-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#Preface"><span class="toc-text">Preface</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%91%98%E8%A6%81"><span class="toc-text">摘要</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-0-%E5%BC%95%E8%A8%80-%E2%80%94%E2%80%94-SystemVerilog-v-s-Verilog%E7%9A%84%E7%9C%9F%E7%9B%B8"><span class="toc-text">1.0 引言 —— SystemVerilog v.s. Verilog的真相</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-text">2 数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-%E5%80%BC%E9%9B%86"><span class="toc-text">2.1 值集</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-%E7%BA%BF%E7%BD%91%E7%B1%BB%E5%9E%8B"><span class="toc-text">2.2 线网类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-%E5%8F%98%E9%87%8F%E7%B1%BB%E5%9E%8B"><span class="toc-text">2.3 变量类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-%E5%90%91%E9%87%8F%E5%A3%B0%E6%98%8E%EF%BC%88%E5%8E%8B%E7%BC%A9%E6%95%B0%E7%BB%84%EF%BC%89"><span class="toc-text">2.4 向量声明（压缩数组）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-5-%E6%95%B0%E7%BB%84%EF%BC%88%E9%9D%9E%E5%8E%8B%E7%BC%A9%E6%95%B0%E7%BB%84%EF%BC%89"><span class="toc-text">2.5 数组（非压缩数组）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#2-5-1-C%E8%AF%AD%E8%A8%80%E9%A3%8E%E6%A0%BC%E7%9A%84%E6%95%B0%E7%BB%84%E5%A3%B0%E6%98%8E"><span class="toc-text">2.5.1 C语言风格的数组声明</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-5-2-%E6%95%B0%E7%BB%84%E5%A4%8D%E5%88%B6"><span class="toc-text">2.5.2 数组复制</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-5-3-%E5%B0%86%E5%80%BC%E5%88%97%E8%A1%A8%E8%B5%8B%E5%80%BC%E7%BB%99%E6%95%B0%E7%BB%84"><span class="toc-text">2.5.3 将值列表赋值给数组</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-5-4-%E5%B0%86%E6%95%B0%E7%BB%84%E4%BC%A0%E9%80%92%E7%BB%99%E6%A8%A1%E5%9D%97%E7%AB%AF%E5%8F%A3%E3%80%81%E4%BB%BB%E5%8A%A1%E5%92%8C%E5%87%BD%E6%95%B0"><span class="toc-text">2.5.4 将数组传递给模块端口、任务和函数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-5-5-%E6%95%B0%E7%BB%84%E6%9F%A5%E8%AF%A2%E7%B3%BB%E7%BB%9F%E5%87%BD%E6%95%B0"><span class="toc-text">2.5.5 数组查询系统函数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-5-6-%E4%B8%8D%E5%8F%AF%E7%BB%BC%E5%90%88%E7%9A%84%E6%95%B0%E7%BB%84%E6%94%B9%E8%BF%9B"><span class="toc-text">2.5.6 不可综合的数组改进</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-6-%E7%94%A8%E6%88%B7%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%9E%8B"><span class="toc-text">2.6 用户定义类型</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#2-6-1-%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%9E%8B"><span class="toc-text">2.6.1 枚举类型</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-6-2-%E7%BB%93%E6%9E%84%E4%BD%93"><span class="toc-text">2.6.2 结构体</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-6-3-%E8%81%94%E5%90%88%E4%BD%93"><span class="toc-text">2.6.3 联合体</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-6-4-%E7%B1%BB%E5%9E%8B%E5%AE%9A%E4%B9%89typedef"><span class="toc-text">2.6.4 类型定义typedef</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%8F%82%E6%95%B0%E5%8C%96%E5%BB%BA%E6%A8%A1"><span class="toc-text">3 参数化建模</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E5%85%B1%E4%BA%AB%E5%A3%B0%E6%98%8E%E7%A9%BA%E9%97%B4-%E2%80%94%E2%80%94-packages%E5%92%8C-unit"><span class="toc-text">4 共享声明空间 —— packages和$unit</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-%E5%8C%85"><span class="toc-text">4.1 包</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#4-1-1-%E5%BC%95%E7%94%A8%E5%8C%85%E5%AE%9A%E4%B9%89"><span class="toc-text">4.1.1 引用包定义</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-1-2-import%E8%AF%AD%E5%8F%A5%E7%9A%84%E4%BD%8D%E7%BD%AE"><span class="toc-text">4.1.2 import语句的位置</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-1-3-%E5%B0%86%E4%B8%80%E4%B8%AA%E5%8C%85%E5%AF%BC%E5%85%A5%E5%8F%A6%E4%B8%80%E4%B8%AA%E5%8C%85%E5%86%85"><span class="toc-text">4.1.3 将一个包导入另一个包内</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-1-4-%E5%8C%85%E7%9A%84%E7%BC%96%E8%AF%91%E9%A1%BA%E5%BA%8F"><span class="toc-text">4.1.4 包的编译顺序</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-unit"><span class="toc-text">4.2 $unit</span></a></li></ol></li></ol></div></div></div></div></main><footer id="footer" style="background-image: url('https://s2.loli.net/2022/04/17/LXdE9NKDcUbeGO8.jpg')"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By stephen zhang</div><div class="footer_custom_text"><a target="_blank" rel="noopener external nofollow noreferrer" href="https://beian.miit.gov.cn/"><img class="icp-icon" src="/images/beian.png"><span>浙ICP备2020030924号-1</span></a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-butterfly/4.13.0/js/utils.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-butterfly/4.13.0/js/main.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/fancyapps-ui/5.0.33/fancybox/fancybox.umd.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/instant.page/5.2.0/instantpage.min.js" type="module"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/17.8.8/lazyload.iife.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/node-snackbar/0.1.16/snackbar.min.js"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://cdnjs.cloudflare.com/ajax/libs/pangu/4.0.7/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (true){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><div class="js-pjax"><script>(() => {
  const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
  if ($mermaid.length === 0) return
  const runMermaid = () => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    Array.from($mermaid).forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const mermaidThemeConfig = '%%{init:{ \'theme\':\'' + theme + '\'}}%%\n'
      const mermaidID = 'mermaid-' + index
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)

      const renderV10 = () => {
        renderFn.then(({svg}) => {
          mermaidSrc.insertAdjacentHTML('afterend', svg)
        })
      }

      const renderV9 = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      typeof renderFn === 'string' ? renderV9(renderFn) : renderV10()
    })
  }

  const loadMermaid = () => {
    window.loadMermaid ? runMermaid() : getScript('https://cdnjs.cloudflare.com/ajax/libs/mermaid/10.8.0/mermaid.min.js').then(runMermaid)
  }

  btf.addGlobalFn('themeChange', runMermaid, 'mermaid')

  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script><script>(()=>{
  const getGiscusTheme = theme => {
    return theme === 'dark' ? 'dark' : 'light'
  }

  const loadGiscus = () => {
    const config = Object.assign({
      src: 'https://giscus.app/client.js',
      'data-repo': 'zhang-stephen/blogs',
      'data-repo-id': 'MDEwOlJlcG9zaXRvcnkzODg0NTQ5OTU=',
      'data-category-id': 'DIC_kwDOFydaU84CPOs_',
      'data-mapping': 'pathname',
      'data-theme': getGiscusTheme(document.documentElement.getAttribute('data-theme')),
      'data-reactions-enabled': '1',
      crossorigin: 'anonymous',
      async: true
    },{"data-mapping":"title","data-input-position":"top","data-loading":"lazy","data-emit-metadata":0})

    const ele = document.createElement('script')
    for (let key in config) {
      ele.setAttribute(key, config[key])
    }
    document.getElementById('giscus-wrap').appendChild(ele)
  }

  const changeGiscusTheme = theme => {
    const sendMessage = message => {
      const iframe = document.querySelector('iframe.giscus-frame')
      if (!iframe) return
      iframe.contentWindow.postMessage({ giscus: message }, 'https://giscus.app')
    }

    sendMessage({
      setConfig: {
        theme: getGiscusTheme(theme)
      }
    });
  }

  btf.addGlobalFn('themeChange', changeGiscusTheme, 'giscus')

  if ('Giscus' === 'Giscus' || !false) {
    if (false) btf.loadComment(document.getElementById('giscus-wrap'), loadGiscus)
    else loadGiscus()
  } else {
    window.loadOtherComment= loadGiscus
  }
})()</script></div><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdnjs.cloudflare.com/ajax/libs/butterfly-extsrc/1.1.3/canvas-fluttering-ribbon.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-butterfly/4.13.0/js/search/local-search.min.js"></script></div></div></body></html>